{
  "version": 1,
  "project": "TypeScript Target Adapter",
  "overview": "Build the first target language adapter for the Criticality Protocol, enabling full protocol support for TypeScript projects. This adapter handles AST manipulation, compiler integration, type witness generation, micro-contract parsing, and property test generation\u2014serving as both the production TypeScript support and reference implementation for future language adapters.",
  "goals": [
    "Enable full Criticality Protocol execution against TypeScript codebases",
    "Provide reliable AST-based code injection using ts-morph",
    "Generate type witnesses with branded types, validation factories, and fast-check Arbitraries",
    "Parse micro-contracts from JSDoc and inline assertions",
    "Generate property-based and behavioral integration tests from spec claims",
    "Generate concurrent tests verifying thread-safety and async consistency",
    "Generate benchmark tests verifying performance and complexity claims",
    "Serve as reference implementation for future language adapters (Rust, Python, Go)"
  ],
  "nonGoals": [
    "CommonJS support (ESM only per project configuration)",
    "Multi-package monorepo with cross-package dependencies (basic workspace detection only)",
    "MCP server exposure (standalone internal adapter)",
    "IDE integration or suggested fixes from compiler errors",
    "Custom configurable shrinking strategies (custom shrinking for witness types only)"
  ],
  "successMetrics": [
    "All adapter operations compile with strict TypeScript (tsconfig strict: true)",
    "100% of injected function bodies result in compilable code",
    "Contract parser correctly extracts all @requires/@ensures/@invariant/@complexity/@purity tags",
    "Type witness generator produces valid branded types with working validation factories",
    "Generated fast-check Arbitraries respect witness invariants",
    "Test generator produces runnable vitest tests for invariant, behavioral, concurrent, and performance claims"
  ],
  "openQuestions": [
    "Potential scope creep: witness generation for deeply nested generic types may require iteration",
    "Performance on large codebases: ts-morph AST parsing may need lazy loading strategies"
  ],
  "stack": {
    "framework": "TypeScript (ESM)",
    "runtime": "Node.js 20+",
    "astLibrary": "ts-morph",
    "testRunner": "vitest",
    "propertyTesting": "fast-check",
    "compiler": "tsc (TypeScript 5.x)"
  },
  "dataModel": [
    {
      "entity": "FunctionSignature",
      "fields": [
        "name",
        "filePath",
        "line",
        "parameters",
        "returnType",
        "typeParameters",
        "isAsync"
      ]
    },
    {
      "entity": "ExtractedType",
      "fields": [
        "name",
        "kind",
        "definition",
        "typeParameters",
        "members"
      ]
    },
    {
      "entity": "MicroContract",
      "fields": [
        "functionName",
        "filePath",
        "requires",
        "ensures",
        "invariants",
        "complexity",
        "purity",
        "claimRefs"
      ]
    },
    {
      "entity": "TypeWitness",
      "fields": [
        "name",
        "baseType",
        "typeParams",
        "invariant",
        "validationFn",
        "arbitraryFn"
      ]
    },
    {
      "entity": "GeneratedTest",
      "fields": [
        "name",
        "filePath",
        "claimId",
        "testType",
        "testCode"
      ]
    },
    {
      "entity": "CompilerError",
      "fields": [
        "file",
        "line",
        "column",
        "code",
        "message",
        "typeDetails"
      ]
    },
    {
      "entity": "TestResult",
      "fields": [
        "name",
        "status",
        "durationMs",
        "error"
      ]
    }
  ],
  "rules": [
    "Fail fast with clear error on malformed contracts (no partial extraction)",
    "Preserve line/column location info for all extracted signatures and contracts",
    "Inject functions in topological order based on call graph (per inject_006)",
    "Support full generic types including unions, intersections, and nested generics for witnesses",
    "Generated tests must be isolated and runnable individually",
    "Custom shrinking for branded/witness types to maintain invariants during shrinking"
  ],
  "qualityGates": [
    "npm run test",
    "npm run lint",
    "npm run typecheck"
  ],
  "stories": [
    {
      "id": "US-001",
      "title": "Integrate ts-morph for AST manipulation",
      "status": "done",
      "dependsOn": [],
      "description": "As a developer, I want to integrate ts-morph into the project so that I can perform reliable AST operations on TypeScript code.",
      "acceptanceCriteria": [
        "Install ts-morph as a dependency: npm install ts-morph",
        "Create src/adapters/typescript/ast.ts module",
        "Export a function createProject(tsConfigPath?: string) that initializes a ts-morph Project",
        "Project should use the target's tsconfig.json if provided, or sensible defaults",
        "Example: createProject('./tsconfig.json') returns a Project instance",
        "Example: createProject() without args uses default compiler options with strict: true",
        "Negative case: createProject('./nonexistent.json') throws clear error with path in message",
        "Add unit tests in src/adapters/typescript/ast.test.ts"
      ],
      "startedAt": "2026-01-25T22:20:36.593366+00:00",
      "completedAt": "2026-01-25T22:24:20.437320+00:00",
      "updatedAt": "2026-01-25T22:24:20.437076+00:00"
    },
    {
      "id": "US-002",
      "title": "Implement TODO detection in function bodies",
      "status": "done",
      "dependsOn": [
        "US-001"
      ],
      "description": "As the orchestrator, I want to detect functions containing throw new Error('TODO') so that I know which functions need implementation during the Injection phase.",
      "acceptanceCriteria": [
        "Export function findTodoFunctions(project: Project): TodoFunction[]",
        "TodoFunction includes: name, filePath, line, signature, hasTodoBody",
        "Detect patterns: throw new Error('TODO'), throw new Error(\"TODO\"), todo!() macro-style comments",
        "Return all functions with TODO bodies sorted by topological order (leaves first)",
        "Example: function add(a: number, b: number) { throw new Error('TODO'); } detected as TODO",
        "Example: function add(a: number, b: number) { return a + b; } NOT detected as TODO",
        "Negative case: throw new Error('Something else') is NOT a TODO marker",
        "Negative case: // TODO comment without throw is NOT detected (comments are not executable)",
        "Add unit tests with fixture files containing various TODO patterns"
      ],
      "startedAt": "2026-01-25T22:24:22.528595+00:00",
      "completedAt": "2026-01-25T22:32:16.310942+00:00",
      "updatedAt": "2026-01-25T22:32:16.310656+00:00"
    },
    {
      "id": "US-003",
      "title": "Implement function signature extraction",
      "status": "done",
      "dependsOn": [
        "US-001"
      ],
      "description": "As the orchestrator, I want to extract complete function signatures so that I can provide them as context to the Injection phase.",
      "acceptanceCriteria": [
        "Export function extractSignature(func: FunctionDeclaration | MethodDeclaration): FunctionSignature",
        "FunctionSignature includes: name, parameters (with types), returnType, typeParameters, isAsync, isGenerator",
        "Handle arrow functions assigned to variables: const fn = (x: T) => ...",
        "Handle method declarations in classes and object literals",
        "Handle overloaded function signatures (return array)",
        "Example: function foo<T>(x: T, y: number): Promise<T> extracts all components correctly",
        "Example: async function bar(): Promise<void> has isAsync=true",
        "Negative case: Anonymous function expressions without variable binding return name as '<anonymous>'",
        "Add unit tests covering all signature variations"
      ],
      "startedAt": "2026-01-25T22:32:18.408624+00:00",
      "completedAt": "2026-01-25T22:40:15.068826+00:00",
      "updatedAt": "2026-01-25T22:40:15.068571+00:00"
    },
    {
      "id": "US-004",
      "title": "Implement type extraction",
      "status": "done",
      "dependsOn": [
        "US-001"
      ],
      "description": "As the orchestrator, I want to extract type definitions referenced by a function so that I can include them in the minimal injection context.",
      "acceptanceCriteria": [
        "Export function extractReferencedTypes(signature: FunctionSignature, project: Project): ExtractedType[]",
        "Follow type references transitively (if Foo references Bar, include both)",
        "Handle: interfaces, type aliases, enums, classes",
        "Handle generic type parameters and their constraints",
        "Handle union types, intersection types, mapped types, conditional types",
        "Include only types from the same project (not node_modules)",
        "Example: function process(user: User): Result extracts User and Result type definitions",
        "Example: type Wrapper<T> = { value: T } with function unwrap<T>(w: Wrapper<T>): T extracts Wrapper",
        "Negative case: Built-in types (string, number, Promise) are not extracted",
        "Negative case: Types from node_modules are not extracted (they're ambient)",
        "Add unit tests with complex type hierarchies"
      ],
      "startedAt": "2026-01-25T22:40:17.161790+00:00",
      "completedAt": "2026-01-25T22:50:38.578671+00:00",
      "updatedAt": "2026-01-25T22:50:38.578439+00:00"
    },
    {
      "id": "US-005",
      "title": "Implement function body injection",
      "status": "done",
      "dependsOn": [
        "US-001",
        "US-002"
      ],
      "description": "As the orchestrator, I want to inject generated function bodies into TODO stubs so that the code becomes functional.",
      "acceptanceCriteria": [
        "Export function injectFunctionBody(project: Project, filePath: string, functionName: string, body: string): void",
        "Replace the existing function body (including throw new Error('TODO')) with the new body",
        "Preserve function signature, decorators, JSDoc comments",
        "Handle async functions (body may contain await)",
        "Handle generator functions (body may contain yield)",
        "Save changes to the source file after injection",
        "Example: Injecting 'return a + b;' into add(a, b) { throw new Error('TODO'); } produces add(a, b) { return a + b; }",
        "Negative case: Attempting to inject into non-existent function throws clear error",
        "Negative case: Injecting syntactically invalid body throws parse error before saving",
        "Add unit tests verifying injection preserves surrounding code"
      ],
      "startedAt": "2026-01-25T22:50:40.666939+00:00",
      "completedAt": "2026-01-25T22:56:43.695908+00:00",
      "updatedAt": "2026-01-25T22:56:43.695666+00:00"
    },
    {
      "id": "US-006",
      "title": "Implement tsc wrapper with structured error output",
      "status": "done",
      "dependsOn": [],
      "description": "As the orchestrator, I want to run TypeScript compilation and receive structured error output so that I can programmatically process compiler feedback.",
      "acceptanceCriteria": [
        "Export function runTypeCheck(projectPath: string, options?: TypeCheckOptions): TypeCheckResult",
        "TypeCheckResult includes: success, errors (array of CompilerError), warningCount, errorCount",
        "CompilerError includes: file, line, column, code (e.g., TS2322), message",
        "Support checking specific files or entire project",
        "Use --noEmit by default (verification only)",
        "Use TypeScript 5.x (latest) as specified",
        "Example: Clean project returns { success: true, errors: [], errorCount: 0 }",
        "Example: Type error returns structured CompilerError with file:line:column location",
        "Negative case: tsc not found in PATH throws ToolchainNotInstalledError",
        "Add integration tests with fixture projects containing type errors"
      ],
      "startedAt": "2026-01-25T22:59:26.018197+00:00",
      "completedAt": "2026-01-26T11:22:00.000000+00:00",
      "updatedAt": "2026-01-26T11:22:00.000000+00:00"
    },
    {
      "id": "US-007",
      "title": "Implement vitest wrapper with structured test output",
      "status": "done",
      "dependsOn": [],
      "description": "As the orchestrator, I want to run vitest and receive structured test results so that I can determine which functions pass their tests.",
      "acceptanceCriteria": [
        "Export function runTests(pattern: string, options?: TestRunOptions): TestRunResult",
        "TestRunResult includes: success, totalTests, passedTests, failedTests, skippedTests, tests (array of TestResult)",
        "TestResult includes: name, file, status, durationMs, error (with assertion message if failed)",
        "Support running specific test files or patterns",
        "Support running specific test names within files (-t flag)",
        "Parse vitest JSON reporter output for structured results",
        "Include detailed error messages and assertion failures for failed tests",
        "Example: All tests pass returns { success: true, failedTests: 0 }",
        "Example: Failed test includes error with assertion details",
        "Negative case: vitest not found throws ToolchainNotInstalledError",
        "Negative case: Invalid test pattern returns empty results, not error",
        "Add integration tests with passing and failing test fixtures"
      ],
      "startedAt": "2026-01-26T09:06:18.864853+00:00",
      "completedAt": "2026-01-26T09:25:29.104762+00:00",
      "updatedAt": "2026-01-26T09:25:29.104606+00:00"
    },
    {
      "id": "US-008",
      "title": "Implement branded type witness generation",
      "status": "done",
      "dependsOn": [
        "US-004"
      ],
      "description": "As the orchestrator, I want to generate branded type definitions so that type witnesses provide compile-time guarantees.",
      "acceptanceCriteria": [
        "Export function generateBrandedType(witness: WitnessDefinition): string",
        "Generate TypeScript branded type pattern: type Name = BaseType & { readonly __brand: unique symbol }",
        "Support all base types: string, number, primitives, objects, arrays",
        "Support generic branded types: type NonEmpty<T> = T[] & { readonly __brand: unique symbol }",
        "Support complex nested generics, unions, and intersections",
        "Generated types must compile with strict: true",
        "Example: NonNegativeDecimal witness generates type NonNegativeDecimal = number & { readonly __brand: unique symbol }",
        "Example: NonEmptyString generates type NonEmptyString = string & { readonly __brand: unique symbol }",
        "Negative case: Invalid base type throws descriptive error",
        "Add unit tests for various witness configurations"
      ],
      "startedAt": "2026-01-26T09:25:31.184241+00:00",
      "completedAt": "2026-01-26T09:31:14.022106+00:00",
      "updatedAt": "2026-01-26T09:31:14.021754+00:00"
    },
    {
      "id": "US-009",
      "title": "Implement validation factory generation",
      "status": "done",
      "dependsOn": [
        "US-008"
      ],
      "description": "As the orchestrator, I want to generate validation factory functions so that runtime values can be validated and branded.",
      "acceptanceCriteria": [
        "Export function generateValidationFactory(witness: WitnessDefinition): string",
        "Generate factory function: function makeXxx(value: BaseType): Xxx | null",
        "Factory validates invariant and returns branded value or null",
        "Generate assertion variant: function assertXxx(value: BaseType): Xxx (throws on invalid)",
        "Generate type guard: function isXxx(value: unknown): value is Xxx",
        "Handle complex invariants with multiple conditions",
        "Example: NonNegativeDecimal generates makeNonNegativeDecimal(n) that returns null for negative numbers",
        "Example: assertNonNegativeDecimal(n) throws for negative numbers with clear message",
        "Negative case: Witness with unsatisfiable invariant generates factory that always succeeds",
        "Add unit tests verifying generated factories work correctly at runtime"
      ],
      "startedAt": "2026-01-26T09:31:16.101492+00:00",
      "completedAt": "2026-01-26T09:39:20.234355+00:00",
      "updatedAt": "2026-01-26T09:39:20.234173+00:00"
    },
    {
      "id": "US-010",
      "title": "Implement runtime assertion generation",
      "status": "done",
      "dependsOn": [
        "US-009"
      ],
      "description": "As the orchestrator, I want to generate runtime assertions so that contracts can be checked during test execution.",
      "acceptanceCriteria": [
        "Export function generateRuntimeAssertions(contract: MicroContract): string",
        "Generate precondition checks from @requires clauses",
        "Generate postcondition checks from @ensures clauses",
        "Generate invariant checks for stateful operations",
        "Assertions throw AssertionError with descriptive message on failure",
        "Support referencing function parameters and return values in assertions",
        "Example: @requires x > 0 generates if (!(x > 0)) throw new AssertionError('Precondition failed: x > 0')",
        "Example: @ensures result !== null generates postcondition check",
        "Negative case: Malformed assertion expression throws parse error",
        "Add unit tests for various contract assertion patterns"
      ],
      "startedAt": "2026-01-26T09:39:22.392278+00:00",
      "completedAt": "2026-01-26T09:47:43.600739+00:00",
      "updatedAt": "2026-01-26T09:47:43.600483+00:00"
    },
    {
      "id": "US-011",
      "title": "Implement fast-check Arbitrary generation",
      "status": "done",
      "dependsOn": [
        "US-008"
      ],
      "description": "As the orchestrator, I want to generate fast-check Arbitrary instances for witness types so that property tests can generate valid test data.",
      "acceptanceCriteria": [
        "Export function generateArbitrary(witness: WitnessDefinition): string",
        "Generate fast-check Arbitrary that produces only valid witness values",
        "Use fc.filter() to enforce invariants on base arbitraries",
        "Support custom shrinking that maintains witness invariants during shrinking",
        "Handle generic witnesses with parameterized arbitraries",
        "Example: NonNegativeDecimal generates fc.float({ min: 0 }).filter(n => n >= 0)",
        "Example: NonEmptyString generates fc.string({ minLength: 1 })",
        "Example: Shrinking NonNegativeDecimal(5) shrinks toward 0, not negative",
        "Negative case: Witness with unsatisfiable invariant generates arbitrary that warns/throws on generation",
        "Add unit tests verifying arbitraries generate valid values and shrink correctly"
      ],
      "startedAt": "2026-01-26T09:47:45.676684+00:00",
      "completedAt": "2026-01-26T09:56:16.572489+00:00",
      "updatedAt": "2026-01-26T09:56:16.572243+00:00"
    },
    {
      "id": "US-012",
      "title": "Implement JSDoc contract parser",
      "status": "done",
      "dependsOn": [
        "US-001"
      ],
      "description": "As the orchestrator, I want to parse micro-contracts from JSDoc comments so that I can extract semantic constraints for injection context.",
      "acceptanceCriteria": [
        "Export function parseContracts(project: Project, filePath: string): MicroContract[]",
        "Parse @requires tags for preconditions",
        "Parse @ensures tags for postconditions",
        "Parse @invariant tags for invariants",
        "Parse @complexity tags for performance requirements (e.g., @complexity O(n))",
        "Parse @purity tags for side effect classification (pure, reads, writes, io)",
        "Extract CLAIM_REF comments linking to spec claim IDs (per contract_003)",
        "Fail fast with clear error message on malformed contract syntax",
        "Example: /** @requires x > 0 @ensures result > x */ correctly extracts both clauses",
        "Example: /** @complexity O(n log n) */ extracts complexity claim",
        "Negative case: @requires without expression throws ContractParseError with line number",
        "Negative case: Unknown tag @foobar is ignored (not an error)",
        "Add unit tests for all contract tag variations"
      ],
      "startedAt": "2026-01-26T09:56:18.653881+00:00",
      "completedAt": "2026-01-26T10:03:50.241172+00:00",
      "updatedAt": "2026-01-26T10:03:50.241008+00:00"
    },
    {
      "id": "US-013",
      "title": "Implement inline assertion parser",
      "status": "done",
      "dependsOn": [
        "US-012"
      ],
      "description": "As the orchestrator, I want to parse inline assertion comments so that contracts can be specified closer to the code.",
      "acceptanceCriteria": [
        "Extend parseContracts to also parse inline comments",
        "Parse // @invariant: expression within function bodies",
        "Parse // @assert: expression for inline assertions",
        "Parse // CLAIM_REF: claim_id for traceability",
        "Associate inline assertions with their containing function",
        "Example: // @invariant: this.count >= 0 inside a method is captured",
        "Example: // CLAIM_REF: perf_001 links the function to spec claim perf_001",
        "Negative case: @invariant in regular comment (not //) is ignored",
        "Negative case: Malformed inline assertion throws with line number",
        "Add unit tests for inline assertion patterns"
      ],
      "startedAt": "2026-01-26T10:03:52.316803+00:00",
      "completedAt": "2026-01-26T10:11:17.228408+00:00",
      "updatedAt": "2026-01-26T10:11:17.227954+00:00"
    },
    {
      "id": "US-014",
      "title": "Implement contract syntax validation",
      "status": "done",
      "dependsOn": [
        "US-012",
        "US-013"
      ],
      "description": "As the orchestrator, I want to validate contract syntax before proceeding so that invalid contracts are caught early.",
      "acceptanceCriteria": [
        "Export function validateContracts(contracts: MicroContract[]): ValidationResult",
        "ValidationResult includes: valid, errors (array of ContractError)",
        "Validate that @requires/@ensures expressions are valid TypeScript expressions",
        "Validate that referenced variables exist in function scope",
        "Validate that @complexity values follow expected patterns (O(1), O(n), O(n^2), etc.)",
        "Validate that @purity values are one of: pure, reads, writes, io",
        "Validate that CLAIM_REF IDs follow expected format",
        "Example: @requires x > 0 with parameter x is valid",
        "Example: @requires nonexistent > 0 fails with 'unknown variable: nonexistent'",
        "Negative case: @complexity O(fast) fails with invalid complexity format",
        "Add unit tests for validation rules"
      ],
      "startedAt": "2026-01-26T10:11:19.307084+00:00",
      "completedAt": "2026-01-26T10:18:34.771010+00:00",
      "updatedAt": "2026-01-26T10:18:34.770782+00:00"
    },
    {
      "id": "US-015",
      "title": "Generate contract objects for injection prompts",
      "status": "done",
      "dependsOn": [
        "US-014"
      ],
      "description": "As the orchestrator, I want to serialize contracts into a format suitable for LLM prompts so that the Injection phase receives structured constraint information.",
      "acceptanceCriteria": [
        "Export function serializeContractForPrompt(contract: MicroContract): string",
        "Output human-readable but structured format",
        "Include all requires/ensures/invariants with clear labels",
        "Include complexity and purity requirements",
        "Exclude CLAIM_REF (internal traceability, not for LLM)",
        "Format should be concise to minimize token usage",
        "Example output: 'REQUIRES: x > 0\nENSURES: result > x\nCOMPLEXITY: O(n)\nPURITY: pure'",
        "Negative case: Contract with no clauses returns empty string",
        "Add unit tests verifying serialization format"
      ],
      "startedAt": "2026-01-26T10:18:36.854497+00:00",
      "completedAt": "2026-01-26T10:23:24.658704+00:00",
      "updatedAt": "2026-01-26T10:23:24.658485+00:00"
    },
    {
      "id": "US-016",
      "title": "Implement claim parser for test generation",
      "status": "done",
      "dependsOn": [],
      "description": "As the orchestrator, I want to parse spec claims so that I can generate appropriate property tests.",
      "acceptanceCriteria": [
        "Export function parseClaims(specPath: string): Claim[]",
        "Claim includes: id, type (invariant|behavioral|negative|temporal|performance|concurrent), description, functions (referenced function names)",
        "Parse claims from spec.toml claims section",
        "Extract claim type from claim category/tags",
        "Extract function references from CLAIM_REF linkage",
        "Example: Claim { id: 'inv_001', type: 'invariant', description: 'balance is never negative' }",
        "Negative case: Claim without type defaults to 'behavioral'",
        "Negative case: Invalid spec.toml throws with parse error details",
        "Add unit tests with example spec files"
      ],
      "startedAt": "2026-01-26T10:28:43.979166+00:00",
      "completedAt": "2026-01-26T11:22:00.000000+00:00",
      "updatedAt": "2026-01-26T11:22:00.000000+00:00"
    },
    {
      "id": "US-017",
      "title": "Generate fast-check property tests for invariant claims",
      "status": "done",
      "dependsOn": [
        "US-011",
        "US-016"
      ],
      "description": "As the orchestrator, I want to generate fast-check property tests so that invariant claims are verified through property-based testing.",
      "acceptanceCriteria": [
        "Export function generateInvariantTest(claim: Claim, witnesses: WitnessDefinition[]): string",
        "Generate vitest test file with fast-check property tests",
        "Use generated Arbitraries for witness types",
        "Test invariant holds for all generated inputs",
        "Include appropriate test timeout for property tests",
        "Generate descriptive test names including claim ID",
        "Example: Claim 'balance never negative' generates test that checks balance >= 0 for random operations",
        "Negative case: Claim without linked functions generates skipped test with TODO",
        "Add unit tests verifying generated test structure"
      ],
      "startedAt": "2026-01-26T11:22:53.223774+00:00",
      "completedAt": "2026-01-26T11:29:03.341396+00:00",
      "updatedAt": "2026-01-26T11:29:03.341212+00:00"
    },
    {
      "id": "US-018",
      "title": "Generate integration tests for behavioral claims",
      "status": "done",
      "dependsOn": [
        "US-016"
      ],
      "description": "As the orchestrator, I want to generate integration tests so that behavioral claims are verified through scenario-based testing.",
      "acceptanceCriteria": [
        "Export function generateBehavioralTest(claim: Claim): string",
        "Generate vitest test file with integration test structure",
        "Support input/output assertion patterns",
        "Support mocking dependencies when needed",
        "Support side-effect verification (function was called, state changed)",
        "Generate setup/teardown hooks as needed",
        "Example: Claim 'transfer moves funds between accounts' generates test with two accounts and balance assertions",
        "Example: Test verifies side effects like 'auditLog.record was called'",
        "Negative case: Claim without clear behavior generates test skeleton with TODO",
        "Add unit tests verifying generated test patterns"
      ],
      "startedAt": "2026-01-26T11:29:05.433652+00:00",
      "completedAt": "2026-01-26T15:19:00.000000+00:00",
      "updatedAt": "2026-01-26T15:19:00.000000+00:00"
    },
    {
      "id": "US-019",
      "title": "Create TypeScript adapter facade",
      "status": "done",
      "dependsOn": [
        "US-005",
        "US-006",
        "US-007",
        "US-015",
        "US-017",
        "US-018",
        "US-023",
        "US-024",
        "US-025"
      ],
      "description": "As the orchestrator, I want a unified adapter interface so that I can interact with TypeScript targets through a consistent API.",
      "acceptanceCriteria": [
        "Create src/adapters/typescript/index.ts as the adapter facade",
        "Export TypeScriptAdapter class implementing TargetAdapter interface",
        "Methods: initialize(projectPath), findTodoFunctions(), extractContext(functionName), inject(functionName, body), verify(), runTests(pattern)",
        "Adapter holds ts-morph Project instance internally",
        "All adapter methods return strongly-typed results",
        "Handle basic monorepo detection (find workspace packages)",
        "Example: const adapter = new TypeScriptAdapter(); adapter.initialize('./project');",
        "Negative case: initialize() on non-TypeScript project throws clear error",
        "Add integration tests exercising full adapter workflow"
      ],
      "startedAt": "2026-01-26T15:25:42.708221+00:00",
      "completedAt": "2026-01-26T15:38:01.069887+00:00",
      "updatedAt": "2026-01-26T15:38:01.069688+00:00"
    },
    {
      "id": "US-020",
      "title": "Implement topological function ordering",
      "status": "done",
      "dependsOn": [
        "US-002",
        "US-003"
      ],
      "description": "As the orchestrator, I want functions ordered by dependency so that injection proceeds from leaves to dependents (per inject_006).",
      "acceptanceCriteria": [
        "Export function orderByDependency(functions: TodoFunction[], project: Project): TodoFunction[]",
        "Build call graph from AST analysis",
        "Return functions in topological order (leaves first)",
        "Handle dependency cycles by grouping cycle members together",
        "Example: If A calls B and B calls C, order is [C, B, A]",
        "Example: If A and B call each other (cycle), they are returned as a batch",
        "Negative case: Function with external-only dependencies (node_modules) is treated as leaf",
        "Add unit tests with various dependency patterns including cycles"
      ],
      "startedAt": "2026-01-26T10:49:22.883097+00:00",
      "completedAt": "2026-01-26T10:55:07.817906+00:00",
      "updatedAt": "2026-01-26T10:55:07.817721+00:00"
    },
    {
      "id": "US-021",
      "title": "Implement signature complexity calculator",
      "status": "done",
      "dependsOn": [
        "US-003"
      ],
      "description": "As the model router, I want to calculate signature complexity so that I can pre-emptively upgrade models for complex functions (per routing_005).",
      "acceptanceCriteria": [
        "Export function calculateSignatureComplexity(signature: FunctionSignature): number",
        "Implement formula: genericParams*2 + unionMembers + nestedTypeDepth + paramCount*0.5",
        "Note: lifetimeParams is Rust-specific, omitted for TypeScript",
        "Count generic type parameters including constraints",
        "Count union members in parameter and return types",
        "Calculate maximum nesting depth of types",
        "Example: function foo<T, U>(x: T | U | null, y: number): Promise<T> has complexity ~5.5",
        "Example: function bar(x: number): number has complexity 0.5",
        "Negative case: Signature with only primitive types has minimal complexity",
        "Add unit tests with complexity calculation verification"
      ],
      "startedAt": "2026-01-26T10:55:09.911065+00:00",
      "completedAt": "2026-01-26T11:00:52.518057+00:00",
      "updatedAt": "2026-01-26T11:00:52.517896+00:00"
    },
    {
      "id": "US-022",
      "title": "Add adapter documentation and examples",
      "status": "done",
      "dependsOn": [
        "US-019"
      ],
      "description": "As a future maintainer, I want documentation for the TypeScript adapter so that I can understand its design and extend it for other languages.",
      "acceptanceCriteria": [
        "Add TSDoc comments to all public exports",
        "Create docs/adapters/typescript.md with architecture overview",
        "Document the TargetAdapter interface contract",
        "Include code examples for common operations",
        "Document how witness/contract/test generation integrates with protocol phases",
        "Reference relevant DECISIONS.toml entries (orch_002, inject_006, routing_005)",
        "Example: Show complete flow from TODO detection through injection to test verification",
        "Negative case: N/A for documentation",
        "Verify documentation builds with TypeDoc without errors"
      ],
      "startedAt": "2026-01-26T15:38:03.240158+00:00",
      "completedAt": "2026-01-26T15:44:56.007281+00:00",
      "updatedAt": "2026-01-26T15:44:56.007085+00:00"
    },
    {
      "id": "US-023",
      "title": "Extract type details from compiler errors",
      "status": "done",
      "dependsOn": [
        "US-006"
      ],
      "description": "As the orchestrator, I want to extract specific type mismatch information from compiler errors so that I can provide targeted feedback for repair.",
      "acceptanceCriteria": [
        "Extend runTypeCheck to enrich CompilerError objects",
        "Parse common TypeScript error messages (e.g., TS2322 'Type X is not assignable to type Y')",
        "Extract structured data: { expected: string, actual: string }",
        "Handle multi-line error details (e.g., mismatched object properties)",
        "Return extended CompilerError structure",
        "Example: Error 'Type string is not assignable to number' yields { expected: 'number', actual: 'string' }",
        "Negative case: Unparseable error messages return null details",
        "Add unit tests with various error message patterns"
      ],
      "startedAt": "2026-01-26T14:53:54.053454+00:00",
      "completedAt": "2026-01-26T15:04:09.522919+00:00",
      "updatedAt": "2026-01-26T15:04:09.522421+00:00"
    },
    {
      "id": "US-024",
      "title": "Generate concurrent tests for concurrency claims",
      "status": "done",
      "dependsOn": [
        "US-016"
      ],
      "description": "As the orchestrator, I want to generate concurrent tests so that thread-safety claims are verified.",
      "acceptanceCriteria": [
        "Export function generateConcurrentTest(claim: Claim): string",
        "Generate vitest test using Promise.all or Node.js worker_threads",
        "Simulate race conditions or parallel access to shared state",
        "Verify invariants hold under concurrent load",
        "Example: Claim 'balance updates are atomic' generates test spawning multiple async transfers",
        "Add unit tests verifying generated test structure"
      ],
      "startedAt": "2026-01-26T15:04:11.662638+00:00",
      "completedAt": "2026-01-26T15:11:42.147139+00:00",
      "updatedAt": "2026-01-26T15:11:42.146724+00:00"
    },
    {
      "id": "US-025",
      "title": "Generate benchmark tests for performance claims",
      "status": "done",
      "dependsOn": [
        "US-016"
      ],
      "description": "As the orchestrator, I want to generate benchmark tests so that complexity claims (Big O) are verified empirically.",
      "acceptanceCriteria": [
        "Export function generateBenchmarkTest(claim: Claim): string",
        "Generate vitest-bench or standalone benchmark script",
        "Measure execution time for exponentially increasing inputs (n=10, 100, 1000)",
        "Fail if scaling violates claimed complexity (e.g., O(1) claim showing linear growth)",
        "Example: Claim 'lookup is O(1)' generates test measuring lookup time at varying map sizes",
        "Add unit tests verifying generated benchmark patterns"
      ],
      "startedAt": "2026-01-26T15:11:44.257215+00:00",
      "completedAt": "2026-01-26T15:17:47.412745+00:00",
      "updatedAt": "2026-01-26T15:17:47.412564+00:00"
    }
  ]
}
