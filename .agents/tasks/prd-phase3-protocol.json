{
  "version": 1,
  "project": "Criticality Protocol Phase 3",
  "overview": "Implementation of the Criticality Protocol, including Ignition, Lattice, Composition Audit, Injection, Mesoscopic, and Mass Defect phases, with full CLI and integration support.",
  "goals": [
    "Implement the full 6-phase protocol end-to-end",
    "Ensure structural criticality via AST-based injection and context shedding",
    "Provide a robust CLI for project initialization and resolving blocking states",
    "Integrate adversarial auditing and security scanning"
  ],
  "nonGoals": [
    "Implementation of features outside the protocol core phases",
    "Full automation without any human-in-the-loop"
  ],
  "successMetrics": [
    "Protocol runs end-to-end on provided examples",
    "100% of generated code passes quality gates",
    "Security scanner catches OWASP Top 10 vulnerabilities"
  ],
  "openQuestions": [
    "How to handle very large modules that exceed context windows during Mass Defect?"
  ],
  "stack": {
    "framework": "TypeScript / Node.js",
    "hosting": "N/A (CLI Tool)",
    "database": "Local JSON/TOML files",
    "auth": "N/A"
  },
  "routes": [],
  "uiNotes": [
    "CLI interface should use clear formatting and helpful error messages"
  ],
  "dataModel": [
    {
      "entity": "InterviewState",
      "fields": [
        "currentPhase",
        "completedPhases",
        "extractedRequirements",
        "delegationPoints",
        "transcript"
      ]
    },
    {
      "entity": "DecisionLedger",
      "fields": [
        "decisions"
      ]
    },
    {
      "entity": "ContradictionReport",
      "fields": [
        "id",
        "severity",
        "involved",
        "analysis",
        "resolutions"
      ]
    }
  ],
  "importFormat": {
    "description": "spec.toml following SPECIFICATION.md schema",
    "example": {}
  },
  "rules": [
    "Context shedding at phase boundaries",
    "Topological ordering for injection",
    "Escalation chain: worker -> fallback -> architect"
  ],
  "qualityGates": [
    "npm run lint",
    "npm run typecheck",
    "npm test"
  ],
  "stories": [
    {
      "id": "US-001",
      "title": "Ignition: Interview state management",
      "status": "done",
      "dependsOn": [],
      "description": "As a developer, I want interview state to be persisted and resumable so that long interviews can survive process restarts.",
      "acceptanceCriteria": [
        "Create InterviewState type with fields: currentPhase, completedPhases, extractedRequirements, delegationPoints, transcript",
        "Implement state persistence to ~/.criticality/projects/<project>/interview/state.json",
        "Implement atomic write pattern (temp file + rename) for state persistence",
        "Implement transcript append to interview/transcript.jsonl",
        "State loads correctly on resume and interview continues from exact position",
        "Example: Start interview, answer 3 questions, kill process, resume -> continues from question 4",
        "Negative case: Corrupted state.json -> returns error with clear message, does not crash"
      ],
      "startedAt": "2026-01-27T13:45:09.677175+00:00",
      "completedAt": "2026-01-29T20:55:34.3Z",
      "updatedAt": "2026-01-29T20:55:34.3Z"
    },
    {
      "id": "US-002",
      "title": "Ignition: Interview structure implementation",
      "status": "done",
      "dependsOn": [
        "US-001"
      ],
      "description": "As a user, I want a structured interview process so that my intent is captured completely and consistently.",
      "acceptanceCriteria": [
        "Implement 6-phase interview structure: Discovery, Architecture, Constraints, Design Preferences, Synthesis, Approval",
        "Discovery and Architecture phases are required; Constraints and Design Preferences support delegation",
        "Implement delegation points with options: Continue, Delegate, Delegate with notes",
        "Record delegation decisions in DecisionLedger with confidence='delegated'",
        "Interview agent uses architect_model via ModelRouter",
        "Approval phase supports conditional approval: 'Approve', 'Approve with conditions', 'Reject with feedback'",
        "Conditional approval records conditions in DecisionLedger and triggers targeted revision of affected sections",
        "Approval requires explicit confirmation of: system boundaries, data models, key constraints, and testable claims",
        "Example: User says 'delegate' at Constraints phase -> remaining constraint decisions made by Architect",
        "Example: User says 'Approve with conditions: add rate limiting' -> condition recorded, Architecture phase revisited for rate limiting",
        "Negative case: User provides contradictory requirements -> flagged for clarification before proceeding"
      ],
      "startedAt": "2026-01-27T13:54:01.298332+00:00",
      "completedAt": "2026-01-29T20:55:34.3Z",
      "updatedAt": "2026-01-29T20:55:34.3Z"
    },
    {
      "id": "US-003",
      "title": "Ignition: CLI interview interface",
      "status": "done",
      "dependsOn": [
        "US-002"
      ],
      "description": "As a user, I want to interact with the interview via CLI so that I can define my project requirements.",
      "acceptanceCriteria": [
        "Implement CLI prompts for interview questions with clear formatting",
        "Support resuming interview with summary of previous answers",
        "Display 'Here's what I understand so far' summary before resuming",
        "Offer confirmation: '[Yes, continue] [No, let me correct something]'",
        "Example: Run criticality init, answer questions, see spec proposal",
        "Negative case: Empty input -> re-prompt with helpful message"
      ],
      "startedAt": "2026-01-27T14:02:00.359567+00:00",
      "completedAt": "2026-01-29T20:55:34.3Z",
      "updatedAt": "2026-01-29T20:55:34.3Z"
    },
    {
      "id": "US-004",
      "title": "Ignition: Programmatic interview API",
      "status": "done",
      "dependsOn": [
        "US-002"
      ],
      "description": "As a developer, I want a programmatic API for interviews so that I can automate and test the interview process.",
      "acceptanceCriteria": [
        "Export InterviewEngine class with methods: start(), answer(), getState(), resume()",
        "API accepts structured responses matching interview question format",
        "API returns current question, available options, and extracted requirements",
        "Example: const engine = new InterviewEngine(); await engine.start(); await engine.answer({phase: 'discovery', response: {...}})",
        "Negative case: Invalid response shape -> throws typed error with validation details"
      ],
      "startedAt": "2026-01-27T14:23:22.313068+00:00",
      "completedAt": "2026-01-29T20:55:34.3Z",
      "updatedAt": "2026-01-29T20:55:34.3Z"
    },
    {
      "id": "US-005",
      "title": "Ignition: Adversarial auditor integration",
      "status": "done",
      "dependsOn": [
        "US-002"
      ],
      "description": "As a developer, I want an adversarial auditor to challenge spec proposals so that contradictions are caught early.",
      "acceptanceCriteria": [
        "Implement auditor prompts that challenge Architect proposals for logical consistency",
        "Auditor uses auditor_model via ModelRouter",
        "Auditor checks for: temporal contradictions, resource conflicts, invariant violations, precondition gaps",
        "Auditor findings presented to user with Architect's response",
        "Example: Auditor detects 'sessions expire after 30min' conflicts with '2-hour operations' -> presents conflict to user",
        "Negative case: Auditor finds no issues -> proceeds without unnecessary blocking"
      ],
      "startedAt": "2026-01-27T14:27:51.181536+00:00",
      "completedAt": "2026-01-29T20:55:34.3Z",
      "updatedAt": "2026-01-29T20:55:34.3Z"
    },
    {
      "id": "US-006",
      "title": "Ignition: Spec artifact generator",
      "status": "done",
      "dependsOn": [
        "US-002",
        "US-005"
      ],
      "description": "As a developer, I want spec.toml generated from interview so that subsequent phases have structured input.",
      "acceptanceCriteria": [
        "Generate spec.toml matching schema from SPECIFICATION.md",
        "Include: meta, system, boundaries, data_models, enums, interfaces, constraints, claims sections",
        "Claims extracted with type (invariant, behavioral, negative, temporal, concurrent, performance) and testable flag",
        "Proposal versions preserved: interview/proposals/v1.toml, v2.toml, etc.",
        "Final approved spec written to project root as spec.toml",
        "Example: Complete interview -> generates valid spec.toml with all sections populated",
        "Negative case: Missing required fields -> validation error before writing"
      ],
      "startedAt": "2026-01-27T14:54:08.126790+00:00",
      "completedAt": "2026-01-29T20:55:34.3Z",
      "updatedAt": "2026-01-29T20:55:34.3Z"
    },
    {
      "id": "US-007",
      "title": "Ignition: Feature classification",
      "status": "done",
      "dependsOn": [
        "US-002"
      ],
      "description": "As a user, I want features classified as Core/Foundational/Bolt-on so that architecture decisions reflect future needs.",
      "acceptanceCriteria": [
        "Interview explicitly asks about feature classification for each major feature",
        "Core features: full implementation in Lattice",
        "Foundational features: skeleton/extension points in Lattice",
        "Bolt-on features: not in Lattice, documented for future",
        "Classification stored in spec.toml under each feature",
        "Example: 'Multi-tenancy as foundational' -> database schema includes tenant_id even if not used in MVP",
        "Negative case: Unclassified feature -> interview prompts for classification before proceeding"
      ],
      "startedAt": "2026-01-27T15:13:23.412084+00:00",
      "completedAt": "2026-01-29T20:55:34.3Z",
      "updatedAt": "2026-01-29T20:55:34.3Z"
    },
    {
      "id": "US-008",
      "title": "Lattice: Module structure generator",
      "status": "done",
      "dependsOn": [
        "US-006"
      ],
      "description": "As a developer, I want module structure generated from spec so that the codebase has proper organization.",
      "acceptanceCriteria": [
        "Parse spec.toml for system boundaries, data models, and interfaces",
        "Generate module hierarchy based on domain boundaries",
        "Create index/barrel files for clean exports",
        "Use TypeScriptAdapter for file generation",
        "Module structure follows existing project conventions if detected",
        "Example: spec with 'account' and 'transaction' domains -> generates src/domain/account/, src/domain/transaction/",
        "Negative case: Empty spec interfaces -> generates minimal structure with placeholder modules"
      ],
      "startedAt": "2026-01-27T15:31:11.108786+00:00",
      "completedAt": "2026-01-29T20:55:34.3Z",
      "updatedAt": "2026-01-29T20:55:34.3Z"
    },
    {
      "id": "US-009",
      "title": "Lattice: Type definition generator",
      "status": "done",
      "dependsOn": [
        "US-008"
      ],
      "description": "As a developer, I want type definitions generated from spec data models so that the type system encodes domain concepts.",
      "acceptanceCriteria": [
        "Generate TypeScript interfaces/types for all spec data_models",
        "Generate enums for all spec enums",
        "Apply constraints as type witnesses where possible (branded types for invariants)",
        "Use TypeScriptAdapter witness generation capabilities",
        "Types include JSDoc comments documenting constraints",
        "Example: Account with balance constraint 'non_negative' -> generates NonNegativeDecimal branded type",
        "Negative case: Unsupported constraint type -> falls back to doc-only with warning"
      ],
      "startedAt": "2026-01-27T21:53:44.793299+00:00",
      "completedAt": "2026-01-29T20:55:34.3Z",
      "updatedAt": "2026-01-29T20:55:34.3Z"
    },
    {
      "id": "US-010",
      "title": "Lattice: Function signature generator",
      "status": "done",
      "dependsOn": [
        "US-009"
      ],
      "description": "As a developer, I want function signatures generated from spec interfaces so that the API surface is defined.",
      "acceptanceCriteria": [
        "Generate function signatures for all spec interface methods",
        "Function bodies contain throw new Error('TODO') placeholder",
        "Signatures use generated type definitions",
        "Use TypeScriptAdapter for signature extraction and body injection",
        "Example: transfer(from: AccountId, to: AccountId, amount: Decimal) -> Result<TransactionId, PaymentError>",
        "Negative case: Invalid type reference in spec -> compilation fails with clear error pointing to spec issue"
      ],
      "startedAt": "2026-01-27T21:56:44.965142+00:00",
      "completedAt": "2026-01-29T20:55:34.3Z",
      "updatedAt": "2026-01-29T20:55:34.3Z"
    },
    {
      "id": "US-011",
      "title": "Lattice: Witness generation integration",
      "status": "done",
      "dependsOn": [
        "US-009"
      ],
      "description": "As a developer, I want type witnesses generated and integrated so that invariants are encoded in the type system.",
      "acceptanceCriteria": [
        "Use existing TypeScriptAdapter witness generation",
        "Generate branded type witnesses for all spec invariants marked as type-encodable",
        "Generate validation factory functions for runtime-only witnesses",
        "Generate fast-check Arbitrary instances for property testing",
        "Produce witness verification tier report showing proof/distinction/runtime/doc levels",
        "Example: SortedArray<T> invariant -> branded type + fromUnsorted factory + isSorted validator",
        "Negative case: Witness generation fails -> logged warning, falls back to runtime validation"
      ],
      "startedAt": "2026-01-27T22:16:01.693442+00:00",
      "completedAt": "2026-01-29T20:55:34.3Z",
      "updatedAt": "2026-01-29T20:55:34.3Z"
    },
    {
      "id": "US-012",
      "title": "Lattice: Contract attachment",
      "status": "done",
      "dependsOn": [
        "US-010"
      ],
      "description": "As a developer, I want micro-contracts attached to all TODO sites so that Injection has semantic guidance.",
      "acceptanceCriteria": [
        "Generate JSDoc micro-contracts for all functions with TODO bodies",
        "Contracts include: @requires, @ensures, @invariant, @complexity, @purity, @claim_ref",
        "Use TypeScriptAdapter contract parser capabilities",
        "CLAIM_REF links to spec claim IDs for traceability",
        "Example: /// @requires amount > 0 /// @ensures self.balance += amount /// @complexity O(1) /// @purity writes /// @claim_ref balance_001",
        "Negative case: Spec claim has no matching function -> warning logged for manual review"
      ],
      "startedAt": "2026-01-27T22:29:36.815092+00:00",
      "completedAt": "2026-01-29T20:55:34.3Z",
      "updatedAt": "2026-01-29T20:55:34.3Z"
    },
    {
      "id": "US-013",
      "title": "Lattice: Compilation verification loop",
      "status": "done",
      "dependsOn": [
        "US-008",
        "US-009",
        "US-010",
        "US-011",
        "US-012"
      ],
      "description": "As a developer, I want Lattice output to always compile so that structural criticality is maintained.",
      "acceptanceCriteria": [
        "Run tsc after Lattice generation",
        "Parse compiler errors using TypeScriptAdapter",
        "Repair structural errors using structurer_model via ModelRouter",
        "Loop until compilation succeeds or max repair attempts reached",
        "Use AST inspection to verify no logic leakage (only type definitions and TODO bodies)",
        "Example: Missing import -> auto-repair adds import statement",
        "Negative case: Unrepairable after 5 attempts -> enter BLOCKED state with compilation errors"
      ],
      "startedAt": "2026-01-27T22:52:35.467328+00:00",
      "completedAt": "2026-01-29T20:55:34.3Z",
      "updatedAt": "2026-01-29T20:55:34.3Z"
    },
    {
      "id": "US-014",
      "title": "Composition Audit: Contradiction detection prompts",
      "status": "done",
      "dependsOn": [
        "US-013"
      ],
      "description": "As a developer, I want contradiction detection so that impossible compositions are caught before Injection.",
      "acceptanceCriteria": [
        "Implement prompts for auditor_model to detect contradictions",
        "Check for: temporal, resource, invariant, precondition gap, postcondition conflict contradictions",
        "Input: spec constraints + function contracts + type witnesses (NOT implementation bodies)",
        "Use architect_model for cross-verification on complex cases",
        "Example: Detect 'session expires 30min' + 'operations take 2hrs' + 'requires active session' conflict",
        "Negative case: No contradictions found -> proceed to Injection immediately"
      ],
      "startedAt": "2026-01-28T08:27:00.424497+00:00",
      "completedAt": "2026-01-29T20:55:34.3Z",
      "updatedAt": "2026-01-29T20:55:34.3Z"
    },
    {
      "id": "US-015",
      "title": "Composition Audit: Contradiction report parser",
      "status": "done",
      "dependsOn": [
        "US-014"
      ],
      "description": "As a developer, I want structured contradiction reports so that failures can be handled programmatically.",
      "acceptanceCriteria": [
        "Parse LLM contradiction output into ContradictionReport type",
        "Report includes: id, severity (critical/warning), involved constraints/contracts, analysis, minimal_scenario, suggested_resolutions",
        "Store reports in project directory for audit",
        "Example: YAML report with TEMPORAL_001 contradiction parsed to typed object",
        "Negative case: Malformed LLM output -> retry with clarification prompt, then fail gracefully"
      ],
      "startedAt": "2026-01-28T08:30:17.135985+00:00",
      "completedAt": "2026-01-29T20:55:34.3Z",
      "updatedAt": "2026-01-29T20:55:34.3Z"
    },
    {
      "id": "US-016",
      "title": "Composition Audit: Phase regression handling",
      "status": "done",
      "dependsOn": [
        "US-015"
      ],
      "description": "As a developer, I want contradictions to trigger targeted revision so that valid work is preserved.",
      "acceptanceCriteria": [
        "Simple contradictions (single constraint conflict) -> return to relevant interview phase",
        "Present contradiction to user with suggested resolutions",
        "Preserve unaffected spec portions",
        "Complex contradictions (multiple interacting) -> BLOCKED state for human guidance",
        "Record contradiction in DecisionLedger",
        "Delegated decisions involved in contradiction downgrade to 'inferred'",
        "Example: Balance invariant conflict -> return to Architecture phase with specific question",
        "Negative case: User rejects all suggested resolutions -> BLOCKED state"
      ],
      "startedAt": "2026-01-28T08:44:36.884567+00:00",
      "completedAt": "2026-01-29T20:55:34.3Z",
      "updatedAt": "2026-01-29T20:55:34.3Z"
    },
    {
      "id": "US-017",
      "title": "Injection: Ralph Loop implementation",
      "status": "done",
      "dependsOn": [
        "US-013"
      ],
      "description": "As a developer, I want the Ralph Loop to implement functions atomically so that context drift is prevented.",
      "acceptanceCriteria": [
        "For each function with TODO: extract local context, prompt model, inject via AST, verify",
        "Local context includes ONLY: signature, contracts, required types, witness definitions",
        "No prior implementation attempts included in context",
        "Use worker_model via ModelRouter as primary",
        "Accept or discard atomically based on compilation + test results",
        "Example: binary_search function -> receives minimal context -> returns implementation -> injected via TypeScriptAdapter",
        "Negative case: Implementation fails compilation -> discarded, fresh retry with same minimal context"
      ],
      "startedAt": "2026-01-28T09:07:29.036108+00:00",
      "completedAt": "2026-01-29T20:55:34.3Z",
      "updatedAt": "2026-01-29T20:55:34.3Z"
    },
    {
      "id": "US-018",
      "title": "Injection: Context extraction",
      "status": "done",
      "dependsOn": [
        "US-017"
      ],
      "description": "As a developer, I want minimal context extracted for each function so that LLM prompts are focused.",
      "acceptanceCriteria": [
        "Extract function signature from AST",
        "Extract micro-contracts from JSDoc",
        "Extract required type definitions (parameters, return type, referenced types)",
        "Extract witness definitions for witnessed types",
        "Context size tracked for model routing decisions",
        "Example: withdraw function -> extracts Account, PositiveDecimal, NonNegativeDecimal, InsufficientFunds types",
        "Negative case: Circular type reference -> detected and flattened to prevent infinite expansion"
      ],
      "startedAt": "2026-01-28T09:24:23.441011+00:00",
      "completedAt": "2026-01-29T20:55:34.3Z",
      "updatedAt": "2026-01-29T20:55:34.3Z"
    },
    {
      "id": "US-019",
      "title": "Injection: Minimal prompt generation",
      "status": "done",
      "dependsOn": [
        "US-018"
      ],
      "description": "As a developer, I want prompts generated in minimal format so that models receive focused instructions.",
      "acceptanceCriteria": [
        "Generate prompt with: FUNCTION, SIGNATURE, CONTRACTS, TYPE DEFINITIONS sections",
        "Prompt ends with 'IMPLEMENT THE FUNCTION. Output only the function body.'",
        "No reasoning traces, no prior attempts, no other functions included",
        "Format matches SPECIFICATION.md example",
        "Example: See SPECIFICATION.md section 4 Injection context isolation example",
        "Negative case: Context exceeds 12k tokens -> trigger pre-emptive model upgrade per routing_002"
      ],
      "startedAt": "2026-01-28T09:37:20.839826+00:00",
      "completedAt": "2026-01-29T20:55:34.3Z",
      "updatedAt": "2026-01-29T20:55:34.3Z"
    },
    {
      "id": "US-020",
      "title": "Injection: AST injection",
      "status": "done",
      "dependsOn": [
        "US-017"
      ],
      "description": "As a developer, I want implementations injected via AST so that code modifications are reliable.",
      "acceptanceCriteria": [
        "Use TypeScriptAdapter for body injection",
        "Replace throw new Error('TODO') with generated implementation",
        "Preserve surrounding code, comments, formatting",
        "Validate injected code parses correctly before writing",
        "Example: Generated body 'return arr.sort()' replaces TODO placeholder",
        "Negative case: Generated code has syntax error -> caught before injection, counts as failure"
      ],
      "startedAt": "2026-01-28T09:40:39.996194+00:00",
      "completedAt": "2026-01-29T20:55:34.3Z",
      "updatedAt": "2026-01-29T20:55:34.3Z"
    },
    {
      "id": "US-021",
      "title": "Injection: Per-function test execution",
      "status": "done",
      "dependsOn": [
        "US-020"
      ],
      "description": "As a developer, I want tests run per function so that failures are isolated.",
      "acceptanceCriteria": [
        "Run tsc after injection to verify compilation",
        "Run unit tests for injected function using vitest",
        "Use TypeScriptAdapter test runner wrapper",
        "Parse test results to determine pass/fail",
        "Example: deposit function injected -> runs deposit.test.ts -> passes -> accepted",
        "Negative case: Test timeout -> counts as failure, logged with timeout context"
      ],
      "startedAt": "2026-01-28T09:53:04.389738+00:00",
      "completedAt": "2026-01-29T20:55:34.3Z",
      "updatedAt": "2026-01-29T20:55:34.3Z"
    },
    {
      "id": "US-022",
      "title": "Injection: Escalation logic",
      "status": "done",
      "dependsOn": [
        "US-021"
      ],
      "description": "As a developer, I want escalation to more capable models so that difficult functions can still be implemented.",
      "acceptanceCriteria": [
        "Implement escalation table from SPECIFICATION.md section 5.4",
        "Escalation chain: worker_model -> fallback_model -> architect_model",
        "Different failure types have different escalation rules",
        "Track attempt counts per model per function",
        "Security vulnerabilities escalate to architect_model immediately",
        "Example: Type error on worker_model attempt 2 -> escalate to fallback_model",
        "Negative case: Syntax error that's clearly recoverable -> retry same model with hint first"
      ],
      "startedAt": "2026-01-28T10:04:23.317221+00:00",
      "completedAt": "2026-01-29T20:55:34.3Z",
      "updatedAt": "2026-01-29T20:55:34.3Z"
    },
    {
      "id": "US-023",
      "title": "Injection: Circuit breaker",
      "status": "done",
      "dependsOn": [
        "US-022"
      ],
      "description": "As a developer, I want a circuit breaker so that runaway failures are stopped.",
      "acceptanceCriteria": [
        "Break if: single function fails across all model tiers (must include architect_model attempt)",
        "Break if: max attempts per function exceeded (default: 8)",
        "Break if: >20% of functions in module escalate",
        "Break if: >10% of all functions fail",
        "On break: return to Lattice with structural defect report",
        "Example: Function fails 8 times across all models -> circuit breaks -> returns to Lattice",
        "Negative case: 19% escalation rate -> continues but logs warning"
      ],
      "startedAt": "2026-01-29T20:32:46.057054+00:00",
      "completedAt": "2026-01-29T20:55:34.3Z",
      "updatedAt": "2026-01-29T20:55:34.3Z"
    },
    {
      "id": "US-024",
      "title": "Injection: Topological ordering",
      "status": "done",
      "dependsOn": [
        "US-017"
      ],
      "description": "As a developer, I want functions injected in topological order so that tests can run in isolation.",
      "acceptanceCriteria": [
        "Build call graph from Lattice AST",
        "Inject leaf functions (no dependencies) first",
        "Inject functions whose dependencies are already injected next",
        "Detect cycles and inject cycle members as batch",
        "Example: utility functions injected before service functions that call them",
        "Negative case: Cycle detected between A, B, C -> all three injected together as batch"
      ],
      "startedAt": "2026-01-29T20:37:15.141540+00:00",
      "completedAt": "2026-01-29T20:55:34.3Z",
      "updatedAt": "2026-01-29T20:55:34.3Z"
    },
    {
      "id": "US-041",
      "title": "Injection: Security vulnerability scanning",
      "status": "done",
      "dependsOn": [
        "US-021"
      ],
      "description": "As a developer, I want generated code scanned for security vulnerabilities so that OWASP Top 10 and CWE issues are caught before acceptance.",
      "acceptanceCriteria": [
        "Integrate security scanning into per-function verification pipeline",
        "Scan for OWASP Top 10 vulnerabilities: injection, broken auth, sensitive data exposure, XXE, broken access control, security misconfiguration, XSS, insecure deserialization, known vulnerabilities, insufficient logging",
        "Scan for common CWE issues: CWE-79 (XSS), CWE-89 (SQL injection), CWE-22 (path traversal), CWE-78 (OS command injection)",
        "Use ESLint security plugins and/or dedicated security scanner",
        "Security vulnerabilities trigger immediate escalation to architect_model per escalation table",
        "Critical vulnerabilities block acceptance regardless of test results",
        "Example: Generated code with SQL string concatenation -> flagged as CWE-89 -> escalated to architect_model",
        "Negative case: No vulnerabilities detected -> proceed with normal test verification"
      ],
      "startedAt": "2026-01-29T20:40:56.920654+00:00",
      "completedAt": "2026-01-29T20:55:34.3Z",
      "updatedAt": "2026-01-29T20:55:34.3Z"
    },
    {
      "id": "US-025",
      "title": "Mesoscopic: Cluster definition",
      "status": "done",
      "dependsOn": [
        "US-023"
      ],
      "description": "As a developer, I want modules grouped into testable clusters so that integration tests are scoped.",
      "acceptanceCriteria": [
        "Group modules based on spec relationships and shared claims",
        "Each cluster has: name, modules list, claims list",
        "Generate cluster definition from spec and code analysis",
        "Cross-module clusters for integration scenarios",
        "Example: auth cluster with [auth, jwt, session] modules and [auth_001, auth_002] claims",
        "Negative case: Orphan module with no claims -> single-module cluster with spec compliance tests"
      ],
      "updatedAt": "2026-01-29T23:11:59.368823+00:00",
      "startedAt": "2026-01-29T23:01:54.483911+00:00",
      "completedAt": "2026-01-29T23:11:59.369069+00:00"
    },
    {
      "id": "US-026",
      "title": "Mesoscopic: Spec-driven test generation",
      "status": "done",
      "dependsOn": [
        "US-025"
      ],
      "description": "As a developer, I want tests generated from spec claims so that verification is requirements-based.",
      "acceptanceCriteria": [
        "Use existing TypeScriptAdapter claim parser",
        "Generate tests for: invariant, behavioral, negative, temporal, concurrent, performance claims",
        "Tests verify spec compliance, not implementation details",
        "Input: spec claims + public interfaces (NOT implementation bodies)",
        "Use structurer_model for test synthesis via ModelRouter",
        "Performance claims generate benchmark tests with configurable thresholds from spec",
        "Performance tests measure: execution time, memory usage, throughput as specified in @complexity contracts",
        "Performance regression detection: compare against baseline if available",
        "Performance test failures logged with metrics but may not block (configurable per claim)",
        "Example: balance_001 claim 'balance >= 0' -> property test with fast-check",
        "Example: perf_001 claim 'search completes in O(log n)' -> benchmark test with scaling verification",
        "Negative case: Untestable claim (testable: false) -> skipped with documentation note",
        "Negative case: Performance claim without threshold -> warning logged, test generated with default threshold"
      ],
      "updatedAt": "2026-01-30T11:23:25.478960+00:00",
      "startedAt": "2026-01-30T10:40:26.010848+00:00",
      "completedAt": "2026-01-30T11:23:25.479739+00:00"
    },
    {
      "id": "US-027",
      "title": "Mesoscopic: Cluster execution",
      "status": "done",
      "dependsOn": [
        "US-026"
      ],
      "description": "As a developer, I want cluster tests executed so that integration issues are detected.",
      "acceptanceCriteria": [
        "Run generated tests for each cluster",
        "Use TypeScriptAdapter vitest wrapper",
        "Collect results per claim",
        "Track which claims pass/fail",
        "Example: Run accounting cluster tests -> balance_001 passes, balance_002 fails",
        "Negative case: Test runner crashes -> logged as infrastructure failure, retry"
      ],
      "updatedAt": "2026-01-30T12:06:24.233569+00:00",
      "startedAt": "2026-01-30T11:23:27.621691+00:00",
      "completedAt": "2026-01-30T12:06:24.233803+00:00"
    },
    {
      "id": "US-028",
      "title": "Mesoscopic: Cluster verdict handling",
      "status": "open",
      "dependsOn": [
        "US-027"
      ],
      "description": "As a developer, I want cluster verdicts handled so that failures trigger appropriate re-injection.",
      "acceptanceCriteria": [
        "ClusterVerdict type: pass or fail with violatedClaims list",
        "On failure: identify functions referenced by violated claims via CLAIM_REF",
        "Only re-inject functions explicitly linked to violated claims",
        "Record violated claims in DecisionLedger",
        "No debugging, no incremental fixes - full re-injection",
        "Example: balance_002 violated -> functions with CLAIM_REF: balance_002 re-injected",
        "Negative case: Claim has no CLAIM_REF links -> re-inject entire cluster (fallback)"
      ],
      "updatedAt": "2026-01-30T12:40:13.513792+00:00",
      "startedAt": "2026-01-30T12:40:13.513600+00:00",
      "completedAt": null
    },
    {
      "id": "US-029",
      "title": "Mass Defect: Complexity analysis integration",
      "status": "open",
      "dependsOn": [
        "US-028"
      ],
      "description": "As a developer, I want complexity metrics analyzed so that code smells are detected.",
      "acceptanceCriteria": [
        "Integrate ESLint for TypeScript complexity analysis",
        "Detect: cyclomatic complexity, nesting depth, function length",
        "Configure thresholds from mass_defect.targets in config",
        "Output list of functions exceeding thresholds with smell IDs",
        "Example: processUser has cyclomatic complexity 15 (target: 10) -> flagged for deep-nesting smell",
        "Negative case: All functions within thresholds -> Mass Defect phase completes immediately"
      ],
      "updatedAt": "2026-01-29T20:55:34.3Z"
    },
    {
      "id": "US-030",
      "title": "Mass Defect: Transformation catalog implementation",
      "status": "open",
      "dependsOn": [
        "US-029"
      ],
      "description": "As a developer, I want a transformation catalog so that code smells have known patterns to apply.",
      "acceptanceCriteria": [
        "Implement smell definitions for all 5 categories: control-flow, duplication, idiom-violation, dead-weight, clarity-debt",
        "Implement all 14 patterns from SPECIFICATION.md: early-return, guard-clause, extract-helper, loop-to-map, loop-to-comprehension, remove-unused-binding, remove-unreachable, inline-single-use, extract-magic-value, introduce-type-alias, optional-chaining, nullish-coalescing, rename-for-clarity, extract-explanatory-variable",
        "Each pattern has: id, name, description, risk, guards, enables, prompt template",
        "Risk levels: 1 (trivial), 2 (safe), 3 (moderate), 4 (structural)",
        "Example: deep-nesting smell -> applicable patterns: early-return (risk 2), extract-conditional-body (risk 3)",
        "Negative case: Unknown smell ID -> logged warning, no patterns applied"
      ],
      "updatedAt": "2026-01-29T20:55:34.3Z"
    },
    {
      "id": "US-031",
      "title": "Mass Defect: Pattern selection algorithm",
      "status": "open",
      "dependsOn": [
        "US-030"
      ],
      "description": "As a developer, I want patterns selected optimally so that low-risk high-value transforms happen first.",
      "acceptanceCriteria": [
        "Implement selectPatterns function from SPECIFICATION.md",
        "Collect applicable patterns from detected smells",
        "Skip patterns already attempted on function",
        "Deduplicate by pattern ID (keep highest severity smell)",
        "Sort by: risk ascending, then enables-count descending",
        "Example: Function has deep-nesting + high-cyclomatic -> early-return (risk 2, enables 2) selected first",
        "Negative case: All applicable patterns already attempted -> return empty list"
      ],
      "updatedAt": "2026-01-29T20:55:34.3Z"
    },
    {
      "id": "US-032",
      "title": "Mass Defect: Transformation application",
      "status": "open",
      "dependsOn": [
        "US-031"
      ],
      "description": "As a developer, I want transformations applied via LLM so that code is refactored correctly.",
      "acceptanceCriteria": [
        "Check guards before applying (skip if any guard condition applies)",
        "Generate transformation prompt with pattern template",
        "Use worker_model for low-risk transforms, architect_model for structural",
        "Apply LLM-generated transformation via TypeScriptAdapter",
        "Example: early-return pattern applied to processUser -> nested ifs flattened",
        "Negative case: Guard 'function has cleanup logic' detected -> pattern skipped"
      ],
      "updatedAt": "2026-01-29T20:55:34.3Z"
    },
    {
      "id": "US-033",
      "title": "Mass Defect: Semantic verification",
      "status": "open",
      "dependsOn": [
        "US-032"
      ],
      "description": "As a developer, I want transformations verified so that semantics are preserved.",
      "acceptanceCriteria": [
        "Verification scope based on risk level: compile-only (1), unit tests (2), integration tests (3), full suite (4)",
        "Accept transformation if verification passes",
        "Revert transformation if verification fails",
        "Track attempted patterns per function to prevent retries",
        "Example: early-return (risk 2) -> run compile + unit tests for target function",
        "Negative case: Transformation breaks test -> reverted, pattern marked as attempted"
      ],
      "updatedAt": "2026-01-29T20:55:34.3Z"
    },
    {
      "id": "US-034",
      "title": "Mass Defect: Iteration until convergence",
      "status": "open",
      "dependsOn": [
        "US-033"
      ],
      "description": "As a developer, I want Mass Defect to iterate until metrics are satisfied so that code quality targets are met.",
      "acceptanceCriteria": [
        "Re-analyze metrics after each successful transformation",
        "Continue applying patterns until: all metrics satisfied OR no applicable patterns remain",
        "Track iteration count for telemetry",
        "Targets from config: max_cyclomatic_complexity=10, max_function_length_lines=50, max_nesting_depth=4",
        "Example: After 3 iterations, all functions below thresholds -> Mass Defect complete",
        "Negative case: Metrics not satisfied but no patterns remain -> complete with warnings logged"
      ],
      "updatedAt": "2026-01-29T20:55:34.3Z"
    },
    {
      "id": "US-035",
      "title": "Blocking state: CLI status command",
      "status": "open",
      "dependsOn": [],
      "description": "As a user, I want a status command so that I can see why the protocol is blocked.",
      "acceptanceCriteria": [
        "Implement 'criticality status' CLI command",
        "Display: current phase, block reason, blocking query, available options",
        "Read-only operation, does not modify state",
        "Works even if main process has exited",
        "Example: criticality status -> 'BLOCKED at Composition Audit: Contradiction detected. Run criticality resolve to provide input.'",
        "Negative case: No active project -> helpful error message"
      ],
      "updatedAt": "2026-01-29T20:55:34.3Z"
    },
    {
      "id": "US-036",
      "title": "Blocking state: CLI resume command",
      "status": "open",
      "dependsOn": [
        "US-035"
      ],
      "description": "As a user, I want a resume command so that I can continue after resolving a block.",
      "acceptanceCriteria": [
        "Implement 'criticality resume' CLI command",
        "Load persisted state from project directory",
        "Continue execution from saved checkpoint",
        "Only ledger decisions persist, not prior LLM context (context shedding)",
        "Example: After resolve, run criticality resume -> protocol continues from Composition Audit",
        "Negative case: No resolution provided for blocking query -> error message prompting criticality resolve"
      ],
      "updatedAt": "2026-01-29T20:55:34.3Z"
    },
    {
      "id": "US-037",
      "title": "Blocking state: CLI resolve command",
      "status": "open",
      "dependsOn": [
        "US-035"
      ],
      "description": "As a user, I want a resolve command so that I can answer blocking queries.",
      "acceptanceCriteria": [
        "Implement 'criticality resolve' CLI command",
        "Display blocking query with available options",
        "Accept user selection or free-form input",
        "Store resolution in persisted state for next resume",
        "Record resolution in DecisionLedger with appropriate confidence",
        "Example: criticality resolve -> shows contradiction options -> user selects resolution -> stored",
        "Negative case: Invalid option selected -> re-prompt with valid options"
      ],
      "updatedAt": "2026-01-29T20:55:34.3Z"
    },
    {
      "id": "US-042",
      "title": "CLI: criticality init command",
      "status": "open",
      "dependsOn": [
        "US-003"
      ],
      "description": "As a user, I want a CLI init command so that I can start a new Criticality project and begin the interview process.",
      "acceptanceCriteria": [
        "Implement 'criticality init' CLI command as entry point for new projects",
        "Create project directory structure: .criticality/, interview/, artifacts/, archive/",
        "Initialize criticality.toml with default configuration",
        "Initialize empty DecisionLedger",
        "Start Ignition phase interview automatically after initialization",
        "Support 'criticality init --from-spec <spec.toml>' to skip interview with existing spec",
        "Detect existing .criticality directory and prompt for confirmation before overwriting",
        "Example: criticality init -> creates project structure -> starts interview",
        "Example: criticality init --from-spec existing-spec.toml -> validates spec -> proceeds to Lattice",
        "Negative case: Directory already initialized -> 'Project already exists. Use criticality resume or criticality init --force'"
      ],
      "updatedAt": "2026-01-29T20:55:34.3Z"
    },
    {
      "id": "US-038",
      "title": "Protocol integration: End-to-end phase transitions",
      "status": "open",
      "dependsOn": [
        "US-006",
        "US-013",
        "US-016",
        "US-023",
        "US-028",
        "US-034"
      ],
      "description": "As a developer, I want all phases connected so that the protocol runs end-to-end.",
      "acceptanceCriteria": [
        "Integrate with existing ProtocolStateMachine for phase transitions",
        "Ignition -> Lattice on spec artifact finalized",
        "Lattice -> Composition Audit on skeleton compiles",
        "Composition Audit -> Injection on no contradictions (or targeted revision complete)",
        "Injection -> Mesoscopic on all TODOs replaced",
        "Mesoscopic -> Mass Defect on all clusters pass",
        "Mass Defect -> Complete on metrics satisfied",
        "Example: Run criticality run -> executes all phases -> produces final artifact",
        "Negative case: Failure at any phase -> appropriate regression or BLOCKED state"
      ],
      "updatedAt": "2026-01-29T20:55:34.3Z"
    },
    {
      "id": "US-039",
      "title": "Protocol integration: Context shedding at boundaries",
      "status": "open",
      "dependsOn": [
        "US-038"
      ],
      "description": "As a developer, I want context shed at phase boundaries so that entropy does not accumulate.",
      "acceptanceCriteria": [
        "Implement shedContext action at each phase boundary",
        "Archive phase artifacts to archive/ directory",
        "Remove all conversation history from active processing",
        "Only structured artifacts (spec.toml, code, contracts) pass to next phase",
        "Archived data NEVER fed back into LLM prompts",
        "Example: Ignition complete -> interview transcript archived -> Lattice receives only spec.toml",
        "Negative case: Archive operation fails -> BLOCKED state for human intervention"
      ],
      "updatedAt": "2026-01-29T20:55:34.3Z"
    },
    {
      "id": "US-040",
      "title": "Protocol integration: Telemetry emission",
      "status": "open",
      "dependsOn": [
        "US-038"
      ],
      "description": "As a developer, I want telemetry emitted so that protocol execution can be monitored.",
      "acceptanceCriteria": [
        "Emit JSON summary to telemetry.json",
        "Emit append-only events to events.jsonl",
        "Events cover: model calls, phase transitions, escalations, blocks",
        "Include cost tracking per model call",
        "Track metrics against targets from DECISIONS.toml metrics_001",
        "Example: Injection escalation event logged with function ID, from_model, to_model, failure_type",
        "Negative case: Telemetry write fails -> logged warning, does not block protocol"
      ],
      "updatedAt": "2026-01-29T20:55:34.3Z"
    }
  ]
}
