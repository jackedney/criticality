/**
 * Concurrent test generator module for TypeScript.
 *
 * Generates tests that verify thread safety and race-condition resistance
 * using Node.js worker_threads as specified in SPECIFICATION.md.
 *
 * @module adapters/typescript/concurrent-test-generator
 */

import type { Claim } from './claims.js';

/**
 * Options for concurrent test generation.
 */
export interface ConcurrentTestOptions {
  /** Number of concurrent workers (default: 4) */
  numWorkers?: number;
  /** Number of iterations per worker (default: 1000) */
  iterationsPerWorker?: number;
  /** Test timeout in milliseconds (default: 60000) */
  timeout?: number;
  /** Whether to include JSDoc comments (default: true) */
  includeJsDoc?: boolean;
}

/**
 * Default number of workers.
 */
const DEFAULT_NUM_WORKERS = 4;

/**
 * Default iterations per worker.
 */
const DEFAULT_ITERATIONS = 1000;

/**
 * Default test timeout in milliseconds.
 */
const DEFAULT_TIMEOUT = 60000;

/**
 * Escapes a string for use in a JavaScript string literal.
 */
function escapeString(str: string): string {
  return str.replace(/'/g, "'").replace(/\n/g, '\n');
}

/**
 * Generates a concurrent test for a claim.
 *
 * The generated test:
 * - Uses Node.js worker_threads for true parallelism
 * - Spawns multiple workers to execute the operation concurrently
 * - Verifies the invariant after all workers complete
 * - Supports cleanup and state verification
 *
 * @param claim - The concurrent claim to generate a test for.
 * @param options - Options for test generation.
 * @returns The generated vitest test file content.
 */
export function generateConcurrentTest(claim: Claim, options: ConcurrentTestOptions = {}): string {
  const {
    numWorkers = DEFAULT_NUM_WORKERS,
    iterationsPerWorker = DEFAULT_ITERATIONS,
    timeout = DEFAULT_TIMEOUT,
    includeJsDoc = true,
  } = options;

  const lines: string[] = [];

  // File header
  if (includeJsDoc) {
    lines.push('/**');
    lines.push(` * Concurrent tests for claim: ${claim.id}`);
    lines.push(' *');
    lines.push(` * ${claim.description}`);
    lines.push(' *');
    lines.push(' * @generated This file was auto-generated by the concurrent test generator.');
    lines.push(' */');
    lines.push('');
  }

  // Imports
  lines.push("import { Worker, isMainThread, parentPort, workerData } from 'node:worker_threads';");
  lines.push("import { fileURLToPath } from 'node:url';");
  lines.push("import { describe, it, expect } from 'vitest';");
  lines.push('');

  // Main thread vs Worker logic
  lines.push('if (isMainThread) {');
  lines.push(`  describe('Concurrent: ${escapeString(claim.description)}', () => {`);
  lines.push(
    `    it('should preserve invariants under parallel execution [${claim.id}]', async () => {`
  );
  lines.push('      const numWorkers = ' + String(numWorkers) + ';');
  lines.push('      const iterations = ' + String(iterationsPerWorker) + ';');
  lines.push('');
  lines.push('      // Arrange: Set up initial state');
  lines.push('      // TODO: Initialize shared state (e.g. database, shared buffer, or service)');
  lines.push('');
  lines.push('      // Act: Spawn workers');
  lines.push('      const workers = Array.from({ length: numWorkers }).map(() => {');
  lines.push('        return new Worker(fileURLToPath(import.meta.url), {');
  lines.push('          workerData: { iterations }');
  lines.push('        });');
  lines.push('      });');
  lines.push('');
  lines.push('      // Wait for all workers to complete');
  lines.push('      await Promise.all(workers.map(worker => {');
  lines.push('        return new Promise((resolve, reject) => {');
  lines.push("          worker.on('exit', (code) => {");
  lines.push(
    '            if (code !== 0) reject(new Error(`Worker stopped with exit code ${code}`));'
  );
  lines.push('            else resolve(null);');
  lines.push('          });');
  lines.push("          worker.on('error', reject);");
  lines.push('        });');
  lines.push('      }));');
  lines.push('');
  lines.push('      // Assert: Verify final state');
  lines.push(
    '      // TODO: Verify that invariant holds (e.g. final balance == initial + total increments)'
  );
  lines.push('      // expect(finalState).toBe(expectedState);');
  lines.push('    }, ' + String(timeout) + ');');
  lines.push('  });');
  lines.push('} else {');
  lines.push('  // Worker Thread Logic');
  lines.push('  (async () => {');
  lines.push('    const { iterations } = workerData;');
  lines.push('');
  lines.push('    // TODO: Import and initialize client for the operation');
  lines.push('    // const client = new ServiceClient();');
  lines.push('');
  lines.push('    for (let i = 0; i < iterations; i++) {');
  lines.push('      // Execute the operation described in the claim');
  lines.push(`      // Claim Operation: ${escapeString(claim.description)}`);
  if (claim.functions.length > 0) {
    const funcName = claim.functions[0] ?? 'unknownFunction';
    lines.push(`      // await ${funcName}(/* args */);`);
  }
  lines.push('    }');
  lines.push('');
  lines.push('    // Signify completion');
  lines.push('    if (parentPort) parentPort.postMessage({ success: true });');
  lines.push('    process.exit(0);');
  lines.push('  })().catch(err => {');
  lines.push('    console.error(err);');
  lines.push('    process.exit(1);');
  lines.push('  });');
  lines.push('}');
  lines.push('');

  return lines.join('\n');
}

/**
 * Generates multiple concurrent tests from an array of claims.
 */
export function generateConcurrentTests(
  claims: Claim[],
  options: ConcurrentTestOptions = {}
): Map<string, string> {
  const tests = new Map<string, string>();

  for (const claim of claims) {
    if (claim.type === 'concurrent') {
      tests.set(claim.id, generateConcurrentTest(claim, options));
    }
  }

  return tests;
}
