/**
 * Concurrent test generator module for TypeScript.
 *
 * Generates tests that verify thread safety and race-condition resistance
 * using Promise.all for async concurrency or Node.js worker_threads
 * for true parallelism, as specified in SPECIFICATION.md.
 *
 * @module adapters/typescript/concurrent-test-generator
 */

import type { Claim } from './claims.js';

/**
 * Strategy for simulating concurrency.
 * - 'promise': Uses Promise.all for async race condition testing (default)
 * - 'worker': Uses Node.js worker_threads for true CPU parallelism
 */
export type ConcurrencyStrategy = 'promise' | 'worker';

/**
 * Options for concurrent test generation.
 */
export interface ConcurrentTestOptions {
  /** Number of concurrent operations/workers (default: 4) */
  numWorkers?: number;
  /** Number of iterations per concurrent operation (default: 1000) */
  iterationsPerWorker?: number;
  /** Test timeout in milliseconds (default: 60000) */
  timeout?: number;
  /** Whether to include JSDoc comments (default: true) */
  includeJsDoc?: boolean;
  /** Concurrency strategy: 'promise' or 'worker' (default: 'promise') */
  strategy?: ConcurrencyStrategy;
}

/**
 * Default number of workers/concurrent operations.
 */
const DEFAULT_NUM_WORKERS = 4;

/**
 * Default iterations per worker.
 */
const DEFAULT_ITERATIONS = 1000;

/**
 * Default test timeout in milliseconds.
 */
const DEFAULT_TIMEOUT = 60000;

/**
 * Default concurrency strategy.
 */
const DEFAULT_STRATEGY: ConcurrencyStrategy = 'promise';

/**
 * Keywords indicating atomic operations in claim descriptions.
 */
const ATOMIC_KEYWORDS = ['atomic', 'atomically', 'atomicity'];

/**
 * Keywords indicating balance/transfer operations.
 */
const BALANCE_KEYWORDS = ['balance', 'transfer', 'transaction', 'fund', 'credit', 'debit'];

/**
 * Escapes a string for use in a JavaScript string literal.
 */
function escapeString(str: string): string {
  return str
    .replace(/\\/g, '\\\\')
    .replace(/'/g, "\\'")
    .replace(/`/g, '\\`')
    .replace(/\$/g, '\\$')
    .replace(/\n/g, '\\n')
    .replace(/\r/g, '\\r');
}

/**
 * Determines if a claim involves atomic/balance operations.
 */
function isBalanceAtomicityClaim(claim: Claim): boolean {
  const lowerDesc = claim.description.toLowerCase();
  const hasAtomic = ATOMIC_KEYWORDS.some((kw) => lowerDesc.includes(kw));
  const hasBalance = BALANCE_KEYWORDS.some((kw) => lowerDesc.includes(kw));
  return hasAtomic && hasBalance;
}

/**
 * Generates header comments for the test file.
 */
function generateFileHeader(claim: Claim, strategy: ConcurrencyStrategy): string[] {
  const lines: string[] = [];
  lines.push('/**');
  lines.push(` * Concurrent tests for claim: ${claim.id}`);
  lines.push(' *');
  lines.push(` * ${claim.description}`);
  lines.push(' *');
  lines.push(
    ` * Strategy: ${strategy === 'promise' ? 'Promise.all (async race conditions)' : 'worker_threads (true parallelism)'}`
  );
  lines.push(' *');
  lines.push(' * @generated This file was auto-generated by the concurrent test generator.');
  lines.push(' */');
  lines.push('');
  return lines;
}

/**
 * Generates a Promise.all-based concurrent test for async race condition testing.
 */
function generatePromiseBasedTest(
  claim: Claim,
  numWorkers: number,
  iterations: number,
  timeout: number
): string[] {
  const lines: string[] = [];
  const isBalanceTest = isBalanceAtomicityClaim(claim);
  const funcName = claim.functions[0] ?? 'operationUnderTest';

  // Imports
  lines.push("import { describe, it, expect } from 'vitest';");
  lines.push('');
  lines.push('// Import functions under test');
  lines.push('// TODO: Import actual implementation once available');
  lines.push(`// import { ${funcName} } from './module.js';`);
  lines.push('');

  // Test suite
  lines.push(`describe('Concurrent: ${escapeString(claim.description)}', () => {`);

  // Main test
  lines.push(
    `  it('should preserve invariants under concurrent execution [${claim.id}]', async () => {`
  );
  lines.push(`    const concurrentOps = ${String(numWorkers)};`);
  lines.push(`    const iterationsPerOp = ${String(iterations)};`);
  lines.push('');
  lines.push('    // Arrange: Set up shared state');

  if (isBalanceTest) {
    // Generate balance atomicity specific test
    lines.push('    // Example: Balance atomicity test setup');
    lines.push('    const initialBalance = 1000;');
    lines.push(
      '    let sharedBalance = initialBalance;  // In real tests, this would be in a database/service'
    );
    lines.push('    const transferAmount = 1;');
    lines.push('');
    lines.push('    // Define the concurrent operation');
    lines.push('    const performTransfer = async (): Promise<void> => {');
    lines.push('      for (let i = 0; i < iterationsPerOp; i++) {');
    lines.push('        // Simulate async transfer operation');
    lines.push(`        // await ${funcName}(transferAmount);`);
    lines.push('        ');
    lines.push('        // This simulates a race condition scenario:');
    lines.push('        // Without proper synchronization, read-modify-write is not atomic');
    lines.push('        const currentBalance = sharedBalance;');
    lines.push('        await Promise.resolve(); // Yield to simulate async timing');
    lines.push('        sharedBalance = currentBalance + transferAmount;');
    lines.push('      }');
    lines.push('    };');
    lines.push('');
    lines.push('    // Act: Execute concurrent transfers');
    lines.push(
      '    const operations = Array.from({ length: concurrentOps }, () => performTransfer());'
    );
    lines.push('    await Promise.all(operations);');
    lines.push('');
    lines.push('    // Assert: Verify atomicity - total should equal expected increments');
    lines.push(
      '    const expectedBalance = initialBalance + (concurrentOps * iterationsPerOp * transferAmount);'
    );
    lines.push('    ');
    lines.push('    // NOTE: This test demonstrates the problem with non-atomic operations.');
    lines.push('    // With proper atomic implementation, this assertion should pass:');
    lines.push('    // expect(sharedBalance).toBe(expectedBalance);');
    lines.push('    ');
    lines.push('    // For now, verify the test ran to completion');
    lines.push(`    expect(sharedBalance).toBeGreaterThanOrEqual(initialBalance);`);
    lines.push('    console.log(`Final balance: ${sharedBalance}, Expected: ${expectedBalance}`);');
  } else {
    // Generic concurrent test
    lines.push('    // TODO: Initialize shared state (e.g., counter, queue, or service)');
    lines.push('    let sharedState = { counter: 0 };');
    lines.push('');
    lines.push('    // Define the concurrent operation');
    lines.push('    const concurrentOperation = async (): Promise<void> => {');
    lines.push('      for (let i = 0; i < iterationsPerOp; i++) {');
    lines.push(`        // Execute the operation described in the claim`);
    lines.push(`        // Claim: ${escapeString(claim.description)}`);
    if (claim.functions.length > 0) {
      lines.push(`        // await ${funcName}(/* args */);`);
    }
    lines.push('        ');
    lines.push('        // Example: Increment shared counter');
    lines.push('        const current = sharedState.counter;');
    lines.push('        await Promise.resolve(); // Yield to simulate async timing');
    lines.push('        sharedState.counter = current + 1;');
    lines.push('      }');
    lines.push('    };');
    lines.push('');
    lines.push('    // Act: Execute operations concurrently using Promise.all');
    lines.push(
      '    const operations = Array.from({ length: concurrentOps }, () => concurrentOperation());'
    );
    lines.push('    await Promise.all(operations);');
    lines.push('');
    lines.push('    // Assert: Verify invariants hold after concurrent execution');
    lines.push('    const expectedCount = concurrentOps * iterationsPerOp;');
    lines.push('    // With proper synchronization, this should pass:');
    lines.push('    // expect(sharedState.counter).toBe(expectedCount);');
    lines.push('    ');
    lines.push('    // Verify test completed');
    lines.push('    expect(sharedState.counter).toBeGreaterThanOrEqual(1);');
    lines.push(
      '    console.log(`Final count: ${sharedState.counter}, Expected: ${expectedCount}`);'
    );
  }

  lines.push(`  }, ${String(timeout)});`);

  // Additional race condition detection test
  lines.push('');
  lines.push(
    `  it('should detect race conditions when synchronization is missing [${claim.id}]', async () => {`
  );
  lines.push('    // This test intentionally creates a race condition to verify');
  lines.push('    // the test harness can detect concurrency issues');
  lines.push('');
  lines.push('    let unsafeCounter = 0;');
  lines.push('    const iterations = 100;');
  lines.push('    const concurrency = 10;');
  lines.push('');
  lines.push('    // Deliberately unsafe operation (no synchronization)');
  lines.push('    const unsafeIncrement = async (): Promise<void> => {');
  lines.push('      for (let i = 0; i < iterations; i++) {');
  lines.push('        const current = unsafeCounter;');
  lines.push('        await Promise.resolve(); // Yield - creates race window');
  lines.push('        unsafeCounter = current + 1;');
  lines.push('      }');
  lines.push('    };');
  lines.push('');
  lines.push('    await Promise.all(');
  lines.push('      Array.from({ length: concurrency }, () => unsafeIncrement())');
  lines.push('    );');
  lines.push('');
  lines.push('    // The final count will often be less than expected due to races');
  lines.push('    const expected = iterations * concurrency;');
  lines.push('    console.log(`Race test - Final: ${unsafeCounter}, Expected: ${expected}`);');
  lines.push('    ');
  lines.push('    // This demonstrates the race condition exists');
  lines.push('    // In a real implementation, you would test that your');
  lines.push('    // synchronized version passes where this fails');
  lines.push('    expect(unsafeCounter).toBeLessThanOrEqual(expected);');
  lines.push(`  }, ${String(timeout)});`);

  lines.push('});');
  lines.push('');

  return lines;
}

/**
 * Generates a worker_threads-based concurrent test for true parallelism.
 */
function generateWorkerBasedTest(
  claim: Claim,
  numWorkers: number,
  iterations: number,
  timeout: number
): string[] {
  const lines: string[] = [];
  const funcName = claim.functions[0] ?? 'operationUnderTest';

  // Imports
  lines.push("import { Worker, isMainThread, parentPort, workerData } from 'node:worker_threads';");
  lines.push("import { fileURLToPath } from 'node:url';");
  lines.push("import { describe, it, expect } from 'vitest';");
  lines.push('');

  // Main thread vs Worker logic
  lines.push('if (isMainThread) {');
  lines.push(`  describe('Concurrent: ${escapeString(claim.description)}', () => {`);
  lines.push(
    `    it('should preserve invariants under parallel execution [${claim.id}]', async () => {`
  );
  lines.push(`      const numWorkers = ${String(numWorkers)};`);
  lines.push(`      const iterations = ${String(iterations)};`);
  lines.push('');
  lines.push('      // Arrange: Set up initial state');
  lines.push(
    '      // TODO: Initialize shared state (e.g. database, SharedArrayBuffer, or service)'
  );

  if (isBalanceAtomicityClaim(claim)) {
    lines.push('');
    lines.push('      // Example for balance atomicity: Use SharedArrayBuffer');
    lines.push('      const sharedBuffer = new SharedArrayBuffer(8);');
    lines.push('      const sharedBalance = new Int32Array(sharedBuffer);');
    lines.push('      const initialBalance = 1000;');
    lines.push('      Atomics.store(sharedBalance, 0, initialBalance);');
  }

  lines.push('');
  lines.push('      // Act: Spawn workers');
  lines.push('      const workers = Array.from({ length: numWorkers }).map(() => {');
  lines.push('        return new Worker(fileURLToPath(import.meta.url), {');

  if (isBalanceAtomicityClaim(claim)) {
    lines.push('          workerData: { iterations, sharedBuffer }');
  } else {
    lines.push('          workerData: { iterations }');
  }

  lines.push('        });');
  lines.push('      });');
  lines.push('');
  lines.push('      // Wait for all workers to complete');
  lines.push('      await Promise.all(workers.map(worker => {');
  lines.push('        return new Promise<void>((resolve, reject) => {');
  lines.push("          worker.on('exit', (code) => {");
  lines.push(
    '            if (code !== 0) reject(new Error(`Worker stopped with exit code ${code}`));'
  );
  lines.push('            else resolve();');
  lines.push('          });');
  lines.push("          worker.on('error', reject);");
  lines.push('        });');
  lines.push('      }));');
  lines.push('');
  lines.push('      // Assert: Verify final state');

  if (isBalanceAtomicityClaim(claim)) {
    lines.push('      const finalBalance = Atomics.load(sharedBalance, 0);');
    lines.push('      const expectedBalance = initialBalance + (numWorkers * iterations);');
    lines.push('      expect(finalBalance).toBe(expectedBalance);');
  } else {
    lines.push(
      '      // TODO: Verify that invariant holds (e.g. final balance == initial + total increments)'
    );
    lines.push('      // expect(finalState).toBe(expectedState);');
    lines.push('      expect(true).toBe(true); // Placeholder - replace with actual assertion');
  }

  lines.push(`    }, ${String(timeout)});`);
  lines.push('  });');
  lines.push('} else {');
  lines.push('  // Worker Thread Logic');
  lines.push('  (async () => {');

  if (isBalanceAtomicityClaim(claim)) {
    lines.push(
      '    const { iterations, sharedBuffer } = workerData as { iterations: number; sharedBuffer: SharedArrayBuffer };'
    );
    lines.push('    const sharedBalance = new Int32Array(sharedBuffer);');
    lines.push('');
    lines.push('    for (let i = 0; i < iterations; i++) {');
    lines.push('      // Atomic increment to ensure thread safety');
    lines.push('      Atomics.add(sharedBalance, 0, 1);');
    lines.push('    }');
  } else {
    lines.push('    const { iterations } = workerData as { iterations: number };');
    lines.push('');
    lines.push('    // TODO: Import and initialize client for the operation');
    lines.push('    // const client = new ServiceClient();');
    lines.push('');
    lines.push('    for (let i = 0; i < iterations; i++) {');
    lines.push('      // Execute the operation described in the claim');
    lines.push(`      // Claim Operation: ${escapeString(claim.description)}`);
    if (claim.functions.length > 0) {
      lines.push(`      // await ${funcName}(/* args */);`);
    }
    lines.push('    }');
  }

  lines.push('');
  lines.push('    // Signify completion');
  lines.push('    if (parentPort) parentPort.postMessage({ success: true });');
  lines.push('    process.exit(0);');
  lines.push('  })().catch(err => {');
  lines.push('    console.error(err);');
  lines.push('    process.exit(1);');
  lines.push('  });');
  lines.push('}');
  lines.push('');

  return lines;
}

/**
 * Generates a concurrent test for a claim.
 *
 * The generated test verifies that invariants hold under concurrent load
 * by simulating race conditions or parallel access to shared state.
 *
 * Two strategies are supported:
 * - 'promise' (default): Uses Promise.all for async race condition testing.
 *   Best for testing async code paths that may have race conditions.
 * - 'worker': Uses Node.js worker_threads for true CPU parallelism.
 *   Best for testing thread-safety with SharedArrayBuffer.
 *
 * @param claim - The concurrent claim to generate a test for.
 * @param options - Options for test generation.
 * @returns The generated vitest test file content.
 *
 * @example
 * ```typescript
 * // Example: Claim 'balance updates are atomic' generates test
 * // spawning multiple async transfers
 * const claim: Claim = {
 *   id: 'conc_001',
 *   type: 'concurrent',
 *   description: 'balance updates are atomic',
 *   functions: ['updateBalance']
 * };
 *
 * const testCode = generateConcurrentTest(claim);
 * // Generates a vitest test that spawns multiple async operations
 * // to verify atomicity of balance updates
 * ```
 */
export function generateConcurrentTest(claim: Claim, options: ConcurrentTestOptions = {}): string {
  const {
    numWorkers = DEFAULT_NUM_WORKERS,
    iterationsPerWorker = DEFAULT_ITERATIONS,
    timeout = DEFAULT_TIMEOUT,
    includeJsDoc = true,
    strategy = DEFAULT_STRATEGY,
  } = options;

  const lines: string[] = [];

  // File header
  if (includeJsDoc) {
    lines.push(...generateFileHeader(claim, strategy));
  }

  // Generate test based on strategy
  if (strategy === 'worker') {
    lines.push(...generateWorkerBasedTest(claim, numWorkers, iterationsPerWorker, timeout));
  } else {
    lines.push(...generatePromiseBasedTest(claim, numWorkers, iterationsPerWorker, timeout));
  }

  return lines.join('\n');
}

/**
 * Generates multiple concurrent tests from an array of claims.
 */
export function generateConcurrentTests(
  claims: Claim[],
  options: ConcurrentTestOptions = {}
): Map<string, string> {
  const tests = new Map<string, string>();

  for (const claim of claims) {
    if (claim.type === 'concurrent') {
      tests.set(claim.id, generateConcurrentTest(claim, options));
    }
  }

  return tests;
}
